using Godot;
using LineForge.Models;
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

namespace LineForge.Services
{
    public class ExportService
    {
        private readonly PreviewService _previewService;

        public ExportService(PreviewService previewService)
        {
            _previewService = previewService;
        }

        public async void ExportToSVG(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var fileDialog = new FileDialog
            {
                FileMode = FileDialog.FileModeEnum.SaveFile,
                Access = FileDialog.AccessEnum.Filesystem,
                Filters = new string[] { "*.svg" }
            };

            fileDialog.FileSelected += (string path) =>
            {
                try
                {
                    string svgContent = GenerateSVG(paperSettings, algoSettings, textSettings);
                    File.WriteAllText(path, svgContent);
                    GD.Print($"SVG exported to: {path}");
                }
                catch (Exception e)
                {
                    GD.PrintErr($"Error exporting SVG: {e.Message}");
                }
            };

            fileDialog.Show();
        }

        public async void ExportToGCode(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var fileDialog = new FileDialog
            {
                FileMode = FileDialog.FileModeEnum.SaveFile,
                Access = FileDialog.AccessEnum.Filesystem,
                Filters = new string[] { "*.gcode" }
            };

            fileDialog.FileSelected += (string path) =>
            {
                try
                {
                    string gcodeContent = GenerateGCode(paperSettings, algoSettings, textSettings);
                    File.WriteAllText(path, gcodeContent);
                    GD.Print($"G-code exported to: {path}");
                }
                catch (Exception e)
                {
                    GD.PrintErr($"Error exporting G-code: {e.Message}");
                }
            };

            fileDialog.Show();
        }

        private string GenerateSVG(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var svg = new StringBuilder();
            var paperSize = GetPaperDimensions(paperSettings.Size);

            // SVG header
            svg.AppendLine($"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
            svg.AppendLine($"<svg width=\"{paperSize.X}mm\" height=\"{paperSize.Y}mm\" xmlns=\"http://www.w3.org/2000/svg\">");

            // Background
            svg.AppendLine($"<rect width=\"100%\" height=\"100%\" fill=\"{ColorToHex(paperSettings.PaperColor)}\"/>");

            // Convert current preview to SVG paths
            var paths = ImageToSVGPaths(_previewService.GetCurrentImage());
            foreach (var path in paths)
            {
                svg.AppendLine($"<path d=\"{path}\" stroke=\"{ColorToHex(paperSettings.PenColor)}\" fill=\"none\" stroke-width=\"0.5\"/>");
            }

            // Add text if present
            if (!string.IsNullOrEmpty(textSettings.Content))
            {
                svg.AppendLine($"<text x=\"{textSettings.Position.X}\" y=\"{textSettings.Position.Y}\" " +
                    $"font-family=\"{textSettings.FontType}\" font-size=\"{textSettings.Size}px\" " +
                    $"transform=\"rotate({textSettings.Rotation} {textSettings.Position.X} {textSettings.Position.Y})\">" +
                    $"{textSettings.Content}</text>");
            }

            svg.AppendLine("</svg>");
            return svg.ToString();
        }

        private string GenerateGCode(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var gcode = new StringBuilder();

            // G-code header
            gcode.AppendLine("; Generated by LineForge");
            gcode.AppendLine("; Paper size: " + paperSettings.Size);
            gcode.AppendLine("; Pen type: " + paperSettings.PenType);

            // Initialize
            gcode.AppendLine("G21 ; Set units to millimeters");
            gcode.AppendLine("G90 ; Use absolute coordinates");
            gcode.AppendLine("G92 X0 Y0 Z0 ; Set current position as home");
            
            // Convert current preview to G-code movements
            var paths = ImageToPlotterPaths(_previewService.GetCurrentImage());
            foreach (var path in paths)
            {
                // Pen up
                gcode.AppendLine("G1 Z5 F1000");
                // Move to start
                gcode.AppendLine($"G1 X{path[0].X:F3} Y{path[0].Y:F3} F3000");
                // Pen down
                gcode.AppendLine("G1 Z0 F1000");
                
                // Draw path
                for (int i = 1; i < path.Count; i++)
                {
                    gcode.AppendLine($"G1 X{path[i].X:F3} Y{path[i].Y:F3} F1500");
                }
            }

            // Return to home
            gcode.AppendLine("G1 Z5 F1000 ; Pen up");
            gcode.AppendLine("G1 X0 Y0 F3000 ; Return to home");

            return gcode.ToString();
        }

        private Vector2 GetPaperDimensions(string paperSize)
        {
            return paperSize.ToUpper() switch
            {
                "A4" => new Vector2(210, 297),
                "US LETTER" => new Vector2(215.9f, 279.4f),
                _ => new Vector2(210, 297) // Default to A4
            };
        }

        private string ColorToHex(Color color)
        {
            return $"#{(int)(color.R * 255):X2}{(int)(color.G * 255):X2}{(int)(color.B * 255):X2}";
        }

        private List<string> ImageToSVGPaths(Image image)
        {
            var pathGenerator = new PathGenerator(image);
            return pathGenerator.GenerateSVGPaths();
        }

        private List<List<Vector2>> ImageToPlotterPaths(Image image)
        {
            var pathGenerator = new PathGenerator(image);
            return pathGenerator.GeneratePlotterPaths();
        }

        public void Apply3DEffects()
        {
            // TODO: Implement 3D effects
            // 1. Create height map from image brightness
            // 2. Generate 3D mesh
            // 3. Apply lighting and rendering
            GD.Print("3D effects not implemented yet");
        }

        public void RotateCanvas(float degrees)
        {
            // TODO: Implement canvas rotation
            // This should rotate both the preview and affect the export coordinates
            GD.Print($"Canvas rotation not implemented yet");
        }
    }
}