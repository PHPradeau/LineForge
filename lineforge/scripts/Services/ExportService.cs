using Godot;
using LineForge.Models;
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

namespace LineForge.Services
{
    public class ExportService
    {
        private readonly PreviewService _previewService;
        private Effects3DService _effects3DService;
        private Window _preview3DWindow;

        public ExportService(PreviewService previewService)
        {
            _previewService = previewService;
        }

        public void ExportToSVG(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var fileDialog = new FileDialog
            {
                FileMode = FileDialog.FileModeEnum.SaveFile,
                Access = FileDialog.AccessEnum.Filesystem,
                Filters = new string[] { "*.svg" }
            };

            fileDialog.FileSelected += OnSVGFileSelected;
            void OnSVGFileSelected(string path)
            {
                try
                {
                    string svgContent = GenerateSVG(paperSettings, algoSettings, textSettings);
                    File.WriteAllText(path, svgContent);
                    GD.Print($"SVG exported to: {path}");
                }
                catch (Exception e)
                {
                    GD.PrintErr($"Error exporting SVG: {e.Message}");
                }
            }

            fileDialog.Show();
        }

        public void ExportToGCode(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var fileDialog = new FileDialog
            {
                FileMode = FileDialog.FileModeEnum.SaveFile,
                Access = FileDialog.AccessEnum.Filesystem,
                Filters = new string[] { "*.gcode" }
            };

            fileDialog.FileSelected += OnGCodeFileSelected;
            void OnGCodeFileSelected(string path)
            {
                try
                {
                    string gcodeContent = GenerateGCode(paperSettings, algoSettings, textSettings);
                    File.WriteAllText(path, gcodeContent);
                    GD.Print($"G-code exported to: {path}");
                }
                catch (Exception e)
                {
                    GD.PrintErr($"Error exporting G-code: {e.Message}");
                }
            }

            fileDialog.Show();
        }

        private string GenerateSVG(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var svg = new StringBuilder();
            var paperSize = PaperSettings.PaperSizes[paperSettings.Size];
            var penProperties = PaperSettings.PenTypes[paperSettings.PenType];

            // SVG header
            svg.AppendLine($"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
            svg.AppendLine($"<svg width=\"{paperSize.X}mm\" height=\"{paperSize.Y}mm\" xmlns=\"http://www.w3.org/2000/svg\">");

            // Background
            svg.AppendLine($"<rect width=\"100%\" height=\"100%\" fill=\"{ColorToHex(paperSettings.PaperColor)}\"/>");

            // Convert current preview to SVG paths
            var paths = ImageToSVGPaths(_previewService.GetCurrentImage());
            foreach (var path in paths)
            {
                svg.AppendLine($"<path d=\"{path}\" stroke=\"{ColorToHex(paperSettings.PenColor)}\" " +
                    $"fill=\"none\" stroke-width=\"{penProperties.Width}mm\"/>");
            }

            // Add text if present
            if (!string.IsNullOrEmpty(textSettings.Content))
            {
                svg.AppendLine($"<text x=\"{textSettings.Position.X}\" y=\"{textSettings.Position.Y}\" " +
                    $"font-family=\"{textSettings.FontName}\" font-size=\"{textSettings.FontSize}px\" " +
                    $"transform=\"rotate({textSettings.Rotation} {textSettings.Position.X} {textSettings.Position.Y})\">" +
                    $"{textSettings.Content}</text>");
            }

            svg.AppendLine("</svg>");
            return svg.ToString();
        }

        private string GenerateGCode(PaperSettings paperSettings, AlgorithmSettings algoSettings, TextSettings textSettings)
        {
            var gcode = new StringBuilder();
            var penProperties = PaperSettings.PenTypes[paperSettings.PenType];

            // G-code header with detailed information
            gcode.AppendLine("; Generated by LineForge");
            gcode.AppendLine($"; Paper size: {paperSettings.Size} ({PaperSettings.PaperSizes[paperSettings.Size].X}mm x {PaperSettings.PaperSizes[paperSettings.Size].Y}mm)");
            gcode.AppendLine($"; Pen type: {paperSettings.PenType}");
            gcode.AppendLine($"; Line width: {penProperties.Width}mm");
            gcode.AppendLine($"; Pressure: {penProperties.Pressure}");

            // Initialize
            gcode.AppendLine("G21 ; Set units to millimeters");
            gcode.AppendLine("G90 ; Use absolute coordinates");
            gcode.AppendLine("G92 X0 Y0 Z0 ; Set current position as home");
            gcode.AppendLine($"M280 P0 S{penProperties.Pressure * 0.5f} ; Set initial pen pressure");
            
            // Convert current preview to G-code movements
            var paths = ImageToPlotterPaths(_previewService.GetCurrentImage());
            foreach (var path in paths)
            {
                // Pen up with minimum pressure
                gcode.AppendLine($"M280 P0 S{penProperties.Pressure * 0.2f} ; Pen up");
                gcode.AppendLine("G1 Z5 F1000");
                
                // Move to start
                gcode.AppendLine($"G1 X{path[0].X:F3} Y{path[0].Y:F3} F3000");
                
                // Pen down with maximum pressure
                gcode.AppendLine("G1 Z0 F1000");
                gcode.AppendLine($"M280 P0 S{penProperties.Pressure} ; Pen down");
                
                // Draw path
                for (int i = 1; i < path.Count; i++)
                {
                    gcode.AppendLine($"G1 X{path[i].X:F3} Y{path[i].Y:F3} F1500");
                }
            }

            // Return to home
            gcode.AppendLine($"M280 P0 S{penProperties.Pressure * 0.2f} ; Pen up");
            gcode.AppendLine("G1 Z5 F1000");
            gcode.AppendLine("G1 X0 Y0 F3000 ; Return to home");

            return gcode.ToString();
        }

        private Vector2 GetPaperDimensions(string paperSize)
        {
            return paperSize.ToUpper() switch
            {
                "A4" => new Vector2(210, 297),
                "US LETTER" => new Vector2(215.9f, 279.4f),
                _ => new Vector2(210, 297) // Default to A4
            };
        }

        private string ColorToHex(Color color)
        {
            return $"#{(int)(color.R * 255):X2}{(int)(color.G * 255):X2}{(int)(color.B * 255):X2}";
        }

        private List<string> ImageToSVGPaths(Image image)
        {
            var pathGenerator = new PathGenerator(image);
            return pathGenerator.GenerateSVGPaths();
        }

        private List<List<Vector2>> ImageToPlotterPaths(Image image)
        {
            var pathGenerator = new PathGenerator(image);
            return pathGenerator.GeneratePlotterPaths();
        }

        public void Apply3DEffects(PaperSettings paperSettings)
        {
            if (_preview3DWindow == null)
            {
                _effects3DService = new Effects3DService();
                CreatePreview3DWindow();
            }

            // Commented out as UpdateEffect method is not implemented
            // _effects3DService.UpdateEffect(_previewService.GetCurrentImage(), paperSettings);
            _preview3DWindow.Show();
        }

        private void CreatePreview3DWindow()
        {
            _preview3DWindow = new Window
            {
                Title = "3D Preview",
                Size = new Vector2I(800, 600),
                Position = new Vector2I(50, 50),
            };

            var container = new VBoxContainer();
            _preview3DWindow.AddChild(container);

            // Add viewport for 3D preview
            var textureRect = new TextureRect
            {
                CustomMinimumSize = new Vector2(800, 550),
                StretchMode = TextureRect.StretchModeEnum.Keep,
                // Commented out as GetViewport method is not implemented
                // Texture = _effects3DService.GetViewport().GetTexture()
            };
            container.AddChild(textureRect);

            // Add rotation controls
            var controls = new HBoxContainer();
            container.AddChild(controls);

            var rotateLeftButton = new Button { Text = "Rotate Left" };
            var rotateRightButton = new Button { Text = "Rotate Right" };
            controls.AddChild(rotateLeftButton);
            controls.AddChild(rotateRightButton);

            // Commented out as RotateView method is not implemented
            // rotateLeftButton.Pressed += () => _effects3DService.RotateView(-90);
            // rotateRightButton.Pressed += () => _effects3DService.RotateView(90);

            _preview3DWindow.CloseRequested += () => _preview3DWindow.Hide();
        }

        public void RotateCanvas(float degrees)
        {
            // TODO: Implement canvas rotation
            // This should rotate both the preview and affect the export coordinates
            GD.Print($"Canvas rotation not implemented yet");
        }
    }
}